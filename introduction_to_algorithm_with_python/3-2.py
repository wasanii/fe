def main():
    # pop = [5224614, 1237984, 1210534, 2301996, 959502,
    #        1068027, 1833152, 2867009, 1933146, 1939110,
    #        7344765, 6284480, 14047594, 9237337, 2201272,
    #        1034814, 1132526, 766863, 809974, 2048011,
    #        1978742, 3633202, 7542415, 1770254, 1413610,
    #        2578087, 8837685, 5465002, 1324473, 922584,
    #        553407, 671126, 1888432, 2799702, 1342059,
    #        719559, 950244, 1334841, 691527, 5135214,
    #        811442, 1312317, 1738301, 1123852, 1069576,
    #        1588256, 1467480]
    pop = [4, 6, 8]
    pref = ['北海道', '青森県', '岩手県', '宮城県', '秋田県',
            '山形県', '福島県', '茨城県', '栃木県', '群馬県',
            '埼玉県', '千葉県', '東京都', '神奈川県', '新潟県',
            '富山県', '石川県', '福井県', '山梨県', '長野県',
            '岐阜県', '静岡県', '愛知県', '三重県', '滋賀県',
            '京都府', '大阪府', '兵庫県', '奈良県', '和歌山県',
            '鳥取県', '島根県', '岡山県', '広島県', '山口県',
            '徳島県', '香川県', '愛媛県', '高知県', '福岡県',
            '佐賀県', '長崎県', '熊本県', '大分県', '宮崎県',
            '鹿児島県', '沖縄県']
    print(pop)
    print(pref)
    ans = choose_prefectures(pop, pref, 10000000)
    print(ans)


def choose_prefectures(pop: list[int], prefs: list[str], goal: int) -> (list[str], int):
    """都道府県別人口から、指定された人口に最も近い組合せとその人口を求める"""

    # 動的計画法の簡単なパターンのはず。荷物の価値を考えないナップサック問題。
    n = len(pop)

    def solve_memorized_recurse(i):
        print(f'i: {i}, dp[{i}]: {dp[i]}')

        # dpが更新されていたら即リターン。dpは1回しか更新されない
        if dp[i] < goal:
            return dp[i]

        # ベースケース 初期状態で残りはgoal
        if i == 0:
            return goal

        # 答えをINFで初期化
        result = goal

        # 緩和処理
        result = min(result, abs(solve_memorized_recurse(i - 1) - pop[i - 1]))

        # 結果をメモ化して返す
        dp[i] = result
        return dp[i]

    dp = [goal] * (n + 1)
    return solve_memorized_recurse(n)


if __name__ == '__main__':
    main()
